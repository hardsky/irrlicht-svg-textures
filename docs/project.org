** Links
http://habrahabr.ru/post/191994/
http://irrlicht.ru/
http://irrlicht.sourceforge.net/forum/viewtopic.php?t=43979


** Установка
1. svn checkout svn://svn.code.sf.net/p/irrlicht/code/trunk irrlicht
2. On the Irrlicht folder type: cd source/Irrlicht && make
3. Install the library and headers from the directory irrlicht-1.#
  1. Type: cd ../..
  2. Type: sudo cp -r include/* /usr/local/include/
  3. Type: sudo cp lib/Linux/libIrrlicht.a /usr/local/lib
4. Compile the examples.
  1. Type: cd examples
  2. Type: chmod +x buildAllExamples.sh
  3. Type: ./buildAllExamples.sh
  4. Type: cd ../bin/Linux

** Особенности
1. librsvg распространяется под лицензией GPL и LGPL, при использовании можно выбрать лицензию которой руководствоваться. 
GPL - предполагает, что если в проекте используется GPL код, то весь остальной код тоже должен распространяться под GPL,
LGPL - при статической линковке требует, чтобы код был открыт, если линковка динамическая (т.е. длл-ка может быть подменена на др версию),
то код может быть под любой лицензией.

** Реализация
1. За образец был взят аналогичный модуль для загрузки .png изображений CImageLoaderPNG.
Модули загрузки изображений унифицированны в Irrlicht и должны реализовывать интерфейс IImageLoader.
2. 
	 IVideoDriver
		virtual ITexture* getTexture(const io::path& filename) = 0;
		virtual ITexture* getTexture(io::IReadFile* file) =0;
3.
Нам интересно, чтобы RSVG создавал изображение под указанные размеры.
Поэтому мы изменили интерфейс 
IVideoDriver.getTexture
чтобы он принимал дополнительно еще и размеры изображения.
Для обратной совместимости, в этом методе аргументы width и height
указанны со значениями по умолчанию, т.е. "старый" способ
getTexture("имя_файла");
работает наравне с
getTexture("имя файла", 100, 100);
"Новый" способ имеет смысл только для svg файлов, для остальных форматов 
ширина/высота не используются.


4. Изменения в CNullDriver.cpp
-------------------
//! loads a Texture
	ITexture* CNullDriver::getTexture(const io::path& filename, int width, int height)
{
	// Identify textures by their absolute filenames if possible.
	const io::path absolutePath = FileSystem->getAbsolutePath(filename);

	ITexture* texture = findTexture(absolutePath);
	if (texture)
	{
		texture->updateSource(ETS_FROM_CACHE);
		return texture;
	}

	// Then try the raw filename, which might be in an Archive
	texture = findTexture(filename);
	if (texture)
	{
		texture->updateSource(ETS_FROM_CACHE);
		return texture;
	}

	io::path textureHash;
	if(width &&  height)
	{
		textureHash += filename;
		textureHash += width;
		textureHash += _IRR_TEXT("x");
		textureHash += height;

		texture = findTexture(textureHash);
		if (texture)
		{
			texture->updateSource(ETS_FROM_CACHE);
			return texture;
		}
	}

	// Now try to open the file using the complete path.
	io::IReadFile* file = FileSystem->createAndOpenFile(absolutePath);

	if (!file)
	{
		// Try to open it using the raw filename.
		file = FileSystem->createAndOpenFile(filename);
	}

	if (file)
	{
		// Re-check name for actual archive names
		texture = findTexture(file->getFileName());
		if (texture)
		{
			texture->updateSource(ETS_FROM_CACHE);
			file->drop();
			return texture;
		}

		texture = loadTextureFromFile(file, textureHash, width, height);
		file->drop();

		if (texture)
		{
			texture->updateSource(ETS_FROM_FILE);
			addTexture(texture);
			texture->drop(); // drop it because we created it, one grab too much
		}
		else
			os::Printer::log("Could not load texture", filename, ELL_ERROR);
		return texture;
	}
	else
	{
		os::Printer::log("Could not open file of texture", filename, ELL_WARNING);
		return 0;
	}
}

-----------------

//! opens the file and loads it into the surface
	video::ITexture* CNullDriver::loadTextureFromFile(io::IReadFile* file, const io::path& hashName, int width, int height)
{
	ITexture* texture = 0;
	IImage* image = createImageFromFile(file, width, height);

	if (image)
	{
		// create texture from surface
		texture = createDeviceDependentTexture(image, hashName.size() ? hashName : file->getFileName() );
		os::Printer::log("Loaded texture", file->getFileName());
		image->drop();
	}

	return texture;
}

----------------

//! Creates a software image from a file.
	IImage* CNullDriver::createImageFromFile(const io::path& filename, int width, int height)
{
	if (!filename.size())
		return 0;

	IImage* image = 0;
	io::IReadFile* file = FileSystem->createAndOpenFile(filename);

	if (file)
	{
		image = createImageFromFile(file, width, height);
		file->drop();
	}
	else
		os::Printer::log("Could not open file of image", filename, ELL_WARNING);

	return image;
}

--------------
	IImage* CNullDriver::createImageFromFile(io::IReadFile* file, int width, int height)
{
	if (!file)
		return 0;

	IImage* image = 0;

	s32 i;

	// try to load file based on file extension
	for (i=SurfaceLoader.size()-1; i>=0; --i)
	{
		if (SurfaceLoader[i]->isALoadableFileExtension(file->getFileName()))
		{
			// reset file position which might have changed due to previous loadImage calls
			file->seek(0);
			image = SurfaceLoader[i]->loadImage(file, width, height);
			if (image)
				return image;
		}
	}

	// try to load file based on what is in it
	for (i=SurfaceLoader.size()-1; i>=0; --i)
	{
		// dito
		file->seek(0);
		if (SurfaceLoader[i]->isALoadableFileFormat(file))
		{
			file->seek(0);
			image = SurfaceLoader[i]->loadImage(file, width, height);
			if (image)
				return image;
		}
	}

	return 0; // failed to load
}
